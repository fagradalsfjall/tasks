### 1. Из каких сегментов состоит структура памяти процесса?

 1. Стек (Stack)
* При обычном объявлении переменных (в том
числе массивов) внутри функций все они создаются в стеке.
* Память на локальные переменные функции
выделяется при вызове этой функции и освобождается при завершении функции.
* Маленький размер (несколько мегабайт, зависит от настроек операционной системы).
* Выделение памяти происходит быстрее чем в
куче

2. Куча (Heap)
* Выделеть память в куче можно с помощью
стандартной функции malloc.
`` int* p = malloc(10 * sizeof(int));``
* Освободить память в куче можно с помощью
стандартной функции free.
* Память можно выделяется/освобождать в
любом месте.
* Размер ограничен свободной оперативной памятью.
* Выделение памяти происходит медленней
чем в стеке.

3. Data
В этом сегменте хранятся инициализированные глобальные и статические переменные а также строковые литералы.

4. BSS
* В этом сегменте хранятся неинициализированные глобальные и статические переменные.
* В большинстве систем все эти данные автоматически инициализируются нулями.

5. Text
* В этом сегменте хранится машинный код программы.
* Адрес функции - адрес первого байта инструкций в этом сегменте.

### 2. Каким образом связаны встроенные указатели и массивы?

Название масива - указатель на его нулевой элемент. Прибавляя к адресу нулевого элемента некоторое число, мы можем получить определенный элемент массива. То есть, например, адрес первого элемента будет представлять выражение a+1, а его значение - *(a+1).

В отношении сложения и вычитания здесь действуют те же правила, что и в операциях с указателями. Добавление единицы означает прибавление к адресу значения, которое равно размеру типа массива. Например, если массив представляет тип int, размер которого, как правило, составляет 4 байта, то прибавление единицы к адресу означает увеличение адреса на 4. Прибавляя к адресу 2, мы увеличиваем значение адреса на 4 * 2 = 8. И так далее.

Но при этом имя массива это не стандартный указатель, и мы не можем изменить его адрес.

### 3. Почему низкоуровневая работа с памятью небезопасна?

Если забыть освободить память с помощью free, когда она перестанет быть нужна, то программа будет
использовать больше памяти чем нужно. Произойдёт так называемая утечка памяти. Если в программе есть
утечки памяти, то с течением времени она будет потреблять всё больше и больше памяти. При завершении
программы вся память освобождается.

Когда приложение съест всю доступную память, сработает защита ОС и программа аварийно закроется. Однако у утечек могут быть и более опасные последствия.

Например, приложение может работать с каким-нибудь файлом непосредственно перед закрытием. В этом случае файл будет повреждён.

В отдельных случаях утечка памяти одного приложения может привести к последствиям для других работающих приложений. Например, если код изменил или занял память, используемую другой программой.

### 4. Что такое ссылка и чем она отличается от указателя?

В простейшем случае ссылка определяется так: если T некоторый тип и есть переменная типа T, то переменная типа T со спецификатором & будет ссылкой на эту переменную, если она инициализирована этой переменной.
    
`` T x; ``
`` T &rx = x; // rx это ссылка на x ``

После этого rx можно использовать в любом контексте вместо x.

* Ключевое отличие между указателями и ссылками состоит в том, что нужно явно использовать оператор * для разыменования указателя (т. е. чтобы обратиться к объекту, на который он указывает), однако для такого же разыменования ссылки не нужно применять специальный оператор.

* Указатель может быть переназначен любое количество раз, в то время как ссылка после привязки не может быть перемещена на другую ячейку памяти.

* Указатели могут указывать "в никуда", в то время как ссылка всегда указывает на определенный объект. GCC может без выдачи предупреждений обработать код наподобие int &x = *(int*)0;, однако поведение подобного кода может быть непредсказуемым.

* Нельзя получить адрес ссылки, как это можно сделать с указателями.

* Не существует арифметики ссылок, в то время как существует арифметика указателей. Однако есть возможность получить адрес объекта, указанного по ссылке, и применить к этому адресу арифметику указателей.

### 5. Какими способами можно передать данные в функцию?
* По значению
* По указателю
* По ссылке