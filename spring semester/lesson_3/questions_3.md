### В каких ситуациях применяются std::pair и std::tuple?
std::tuple (кортеж) — это коллекция фиксированного размера, содержащая разнородные значения.
std::pair (пара) — принимает два шаблонных параметра, <T, U>. std::tuple принимает переменное количество аргументов. Так что это обобщение std::pair, поскольку оно может принимать любое количество аргументов/значений.

### Когда следует использовать std::array?
std::array<T, N> это простейший контейнер. Его семантика ничем не отличается от обычного массива T[N]. Эти объекты лежат на стеке. Ни добавлять, ни удалять объекты нельзя, их ровно N. Особенность std::array (а точнее, массива T[N]) в том, что все объекты, которые в нем находятся, инициализируются немедленно и сразу готовы к употреблению.

### Когда следует использовать std::vector?
std::vector<T> аллоцирует память для объектов в куче. На стеке лежат три указателя: на первый объект (begin), на следующий за последним объектом (end), и на следующий за последним доступным участком памяти (end_cap). Объекты из старой памяти нужно переместить в новую память, и потом освободить старую память.

### Когда следует использовать std::deque?
std::deque16 (double-ended queue) это контейнер с быстрым добавлением объектов в начало и в конец. Если std::vector это сплошной кусок памяти, то в std::deque вся память разбивается на несколько кусков памяти (чанков) одинаковой величины. 

Плюс контейнера в том, что при добавлении новых объектов в начало/конец никакие существующие ссылки/указатели на другие объекты контейнера не инвалидируются.

Минус контейнера в оверхеде по памяти, который более ощутим если объектов мало. std::deque<T> с одним объектом аллоцирует чанк немаленького размера (в реализации STL от Clang чанк занимает минимум 4096 байт).

### Когда следует использовать std::forward_list?
std::forward_list18 это однонаправленный список - самая простая реализация списка. Список состоит из вершин. Вершина списка это сам объект и указатель на следующую вершину (указатель принимает значение nullptr, если объект последний в списке). Для каждой вершины память аллоцируется отдельно, размером sizeof(T) + sizeof(void*) байт.

Контейнер поддерживает быструю вставку и удаление объектов в любом месте, потому что для этого понадобится только правка next_ptr у вершины слева. Впрочем, "быстрая вставка" относится исключительно к "алгоритмической сложности". Аллокация памяти для новой вершины может быть небыстрой.

Быстро получить N-й объект нельзя, для этого нужно пройтись от корневой вершины по next_ptr N раз. Размер списка тоже можно узнать только пройдя по всем next_ptr, пока не увидим nullptr. У контейнера даже нет метода .size().

Итераторы и указатели на объект в этом контейнере никогда не инвалидируются, пока не будет удален сам объект. Это максимально сильные гарантии среди всех контейнеров.

### Когда следует использовать std::list?
std::list19 это более сложная организация списка. Она имеет все те же свойства, как у std::forward_list, но вершины дополнительно могут ссылаться на предыдущие вершины, и есть быстрое добавление в конец списка.

### Какие адаптеры контейнеров есть в стандартной библиотеке?
Некоторые контейнеры не имеют хитрого внутреннего устройства, и их функционал базируется на функционале какого-нибудь другого контейнера. В STL таких контейнеров три: std::stack, std::queue, std::priority_queue, в каждом можно выбрать "реальный" контейнер.

### Когда следует использовать circular buffer из Boost?
Плюс контейнера - быстрое удаление/вставка в начале. Минус контейнера - жесткое ограничение по памяти в N объектов. Подойдет, если нужно хранить фиксированное количество самых новых записей.

### Почему контейнер circular buffer из Boost не может войти в стандарт?
В Boost множество разноцелевых библиотек, сейчас не для всех из них найдется место в стандарте, так как они слишком специализированные, зависят от контекста или просто не настолько популярны, чтобы переносить их в сам язык.
