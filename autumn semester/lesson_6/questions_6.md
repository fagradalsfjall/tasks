### 1. Перечислите все специальные функции-члены класса, включая перемещающие операции

Конструктор по умолчанию, деструктор, конструктор копирования и оператор назначения копирования, конструктор перемещения и оператор присваивания перемещения.

### 2. Приведите примеры операторов, которые можно, нельзя и не рекомендуется перегружать

Cтандарт *разрешает перегружать* следующие операторы: `+, -, *, /, %, ^, &, |, ~, !, ,, =, <, >, <=, >=, ++, –-, <<, >>, ==, !=, &&, ||, +=, -=, /=, %=, ^=, &=, |=, *=, <<=, >>=, [], (), ->, ->*, new, new[], delete, delete[]`. 

Следующие операторы *перегружать нельзя*: ?: (тернарный оператор); :: (доступ к вложенным именам); . (доступ к полям); .* (доступ к полям по указателю); sizeof, typeid.

*Не рекомендуется перегружать* следующие три бинарных оператора: , (запятая); &&; ||. Для них стандарт предусматривает порядок вычисления операндов (слева направо), а для последних двух еще и так называемую семантику быстрых вычислений (short-circuit evaluation), но для перегруженных операторов это уже не гарантируется или просто бессмысленно. (Семантика быстрых вычислений, называемая еще закорачиванием, заключается в том, для оператора && второй операнд не вычисляется, если первый равен false, а для оператора || второй операнд не вычисляется, если первый равен true).

### 3. О каких преобразованиях следует помнить при проектировании операторов?

Следует помнить про неявные преобразования типов: например, мы перегружаем оператор `+` для нашего класса. И пусть второй класс имеет преобразование к объекту типа первого класса. Тогда оператор `+` автоматически становится перегруженным для объектов второго класса (вследствие неявного преобразования типов). Это может приводить к ошибкам в логике работы программы.

### 4. Опишите классификацию выражений на основе перемещаемости и идентифицируемости

Обладающие идентичностью выражения обобщены под термином glvalue (generalized values), перемещаемые выражения называются rvalue.

|                          | Обладают идентичностью | Лишены идентичности |
|:------------------------:|:----------------------:|:-------------------:|
| Не могут быть перемещены | lvalue                 | –                   |
| Могут быть перемещены    | xvalue                 | prvalue             |

* lvalue (от left-hand value – значение слева от равно) – фактически всё, чему может быть присвоено значение, например, переменная, результат разыменовывания указателя, ссылка.

* prvalue (от pure rvalue) – выражение, которое непосредственно инициализирует объект или описывает операнд, например, результат вызова функции, не являющийся ссылкой, результат постфиксных инкремента или декремента, результат арифметической операции.

* xvalue (от expiring value) – объекты, которые близки к концу времени жизни (lifetime). Фактически xvalue – это анонимные ссылки на rvalue (о ссылках на rvalue – чуть позже), например, результаты вызова функций, возвращающих ссылки на rvalue.

### 5. Зачем нужны rvalue-ссылки?

Rvalue ссылка ведет себя точно так же, как и lvalue ссылка, за исключением того, что она может быть связана с временным объектом, тогда как lvalue связать с временным (не константным) объектом нельзя.

Комбинация rvalue ссылок и lvalue ссылок — это то, что необходимо для лёгкой реализации семантики перемещения (move semantics). Rvalue ссылка может также использоваться для достижения идеальной передачи (perfect forwarding). Rvalue ссылки позволяют создать более производительные библиотеки.

### 6. Почему семантика перемещения лучше копирования?

Операция перемещения данных передает владение данными от одного объекта к другому и в большинстве случаев не изменяет размещение этих данных физически в памяти. Это позволяет избежать дорогостоящего копирования.

### 7. Что делает функция std::move и когда нет необходимости ее вызывать?

`std::move` – это функция из стандартной библиотеки, определённая в хедере `<utility>`, которая позволяет взять, что угодно (например, lvalue), и сделать из этого rvalue (xvalue, если быть точным). Это даёт нам возможность перемещать объекты, rvalue-ссылок на которые у нас нет.

Нет необходимости вызывать `std::move`: когда объект инициализируется rvalue (вызывается конструктор перемещения), когда объекту присваивается rvalue (вызывается оператор перемещения). 

### 8. Для чего нужны ключевые слова default и delete в объявлении специальных функций-членов класса?

Ключевое слово default указывает компилятору самостоятельно генерировать соответствующую функцию класса, если таковая не объявлена в классе.

Как известно, компилятор автоматически генерирует ряд конструкторов класса и деструктор. Указание ключевого слова default для этих функций дает следующие взаимосвязанные преимущества:

* программист получает понятную информацию об отсутствии реализации отдельных функций в классе. Используються компиляторные версии этих функций;
* упрощается восприятие информации об особенностях использования тех или иных функций класса. Вместо того чтобы вспоминать правила программист указывает то, что хочет получить.

Ключевое слово delete используется в случаях, когда нужно запретить автоматическое приведение типов в конструкторах и методах класса.