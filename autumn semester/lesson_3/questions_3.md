### 1. В чем заключается концепция встраивания вызовов функций?

С++ предлагает возможность совместить все преимущества функций вместе с высокой производительностью кода, написанного "на месте". Речь идет о встроенных функциях.

Существуют два способа сообщить компилятору, что встраивание функций может быть желательно: с помощью ключевых слов inline и с помощью функций-членов класса.

**Ключевое слово inline.** Это директива, которая сообщает компилятору, что функция должна быть встроена. Компилятор волен проигнорировать такой запрос, если функция является слишком большой или это идет в разрез с настройками оптимизации (например, если имеется установка получить компактный код вместо быстрого кода). Ключевое слово inline сегодня также доступно в большинстве современных C-компиляторов в качестве расширения языка, и работает оно по тому же принципу.

Хотя это ключевое слово кажется чрезвычайно полезным, оно таит в себе скрытую опасность, так как может привести к чрезмерному потреблению памяти:

* Если встроенная функция вызывается несколько раз, то, естественно, в программе появится несколько копий ее кода. В зависимости от величины функции и от количества вызовов получим соответствующий объем используемой памяти. Впрочем, это не должно быть сюрпризом.

* Если функция объявлена как inline, но также является статической, компилятор сможет встроить эту функцию в текущий модуль, но ему потребуется также сгенерировать "невстроенную", внешнюю копию в случае, если вызов происходит из другой функции. В итоге, в такой проблеме будет разбираться уже компоновщик. Все что необходимо компоновщику, это обнаружить функции-"сироты", то есть функции, которые ни откуда не вызываются, и у него есть инструменты для этого дела.

**Функции-члены класса.** В C++ класс (и, по сути, структура) может включать в себя и функции, и код. Существуют два способа определения функций-членов. Код может быть включен в определении класса, или функция-член может быть определена и объявлена где-то снаружи.

### 2. Какие аргументы функции могут иметь значения по умолчанию?

Во многих случаях функции имеют аргументы, которые используются настолько редко, что достаточно значения по умолчанию. В таких случаях возможность задания аргументов по умолчанию позволяет указывать только те аргументы функции, которые важны в конкретном вызове.

### 3. На основании чего разрешается выбор пергруженной функции?

Выбор перегруженной функции осуществляется в несколько этапов:

    1.	C++ пытается найти точное совпадение. Это тот случай, когда фактический аргумент точно соответствует типу параметра одной из перегруженных функций.

    2.	Если точного совпадения не найдено, то C++ пытается найти совпадение путем дальнейшего неявного преобразования типов:

        •	 char, unsigned char и short конвертируются в int;
        •	 unsigned short может конвертироваться в int или unsigned int (в зависимости от размера int); 
        •	 float конвертируется в double; 
        •	 enum конвертируется в int.

    3.	Если неявное преобразование невозможно, то C++ пытается найти соответствие посредством стандартного преобразования

    4.	C++ пытается найти соответствие путем пользовательского преобразования


### 4. Лямбда-выражения

Лямбда-выражения — это удобный способ определения анонимного объекта функции в расположении, где он вызывается или передается в качестве аргумента функции. Как правило, лямбда-выражения используются для инкапсуляции нескольких строк кода, передаваемых алгоритмам или асинхронным функциям.

### 5. По каким причинам макросы считаются опасным инструментом?

Макросы игнорируют области видимости, игнорируют прочие возможности и правила языка, и заменяют все символы, которые переопределяют при помощи директивы #define, до самого конца файла. Применение макросов внешне походит на имя или вызов функции, но не имеет с ними ничего общего. Макросы могут быть раскрыты неожиданно, причем превратиться в зависимости от контекста их использования в самые разные конструкции. Также макросы не имеют пространства имен.